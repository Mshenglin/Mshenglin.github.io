---
title: 复杂度分析
date: 2019-09-10 19:32:38
tags: 数据结构与算法
categories: 数据结构
---

## 为什么要复杂度分析？ 



1. 测试结果非常依赖环境。

   在不同的机器，不同的环境下测试的结果是不相同的，比如在一台机器中，a代码执行的速度比b代码块，等我们换台电脑，会有截然不同的结果。

2. 测试结果受数据规模的影响。

   由于存在极端的情况，会对实验的数据有一定的影响。

   ## O的理解

   

   ​      大O时间复杂度实际上并不代表代码真正的执行时间，他只是表示代码时间随数据规模增长的变化趋势，所以，也被称为渐进时间复杂度。简称时间复杂度。

   ​		从计算机执行代码来看，每一行代码都执行着类似的操作，读数据-运算-处理数据，所以我们可以大概的设计算机处理一行代码的时间为1TIME，就以下代码进行分析。

   ```
   int n=100;
           int sum=0;
           for (int i = 0; i <100; i++) {
               sum+=i;
           }
   ```

   在这段代码中，代码执行的时间为T(n)=(100*2+1) * TIME

   ```java
    int sum=0;
           for (int i = 0; i <n ; i++) {
               sum+=i;
           }
       }
   ```

   就这段代码，代码执行的时间为T(n)=(1+2n)*TIME

   细心的你可能会疑惑，这两段代码存在着细微的差别，在上面的那段代码中，那个循环执行了100次，他是常量级的？而下面的那个换成一个变量就变成n呢？

   这就是对时间复杂度概念进行理解，时间复杂度表示的是算法的执行效率与数据规模变化增长的变化趋势。所以常量无论多大，我们都可以忽略掉。即便这段代码执行了上万次，他始终是一个常量级的。

   通过上面的例子，我们就可以总结进行总结。

   ​                          											**T(n)=O(f(n))**

   其中T(n)表示执行代码所用的时间，n表示数据规模的大小，f(n)表示代码执行的总次数。我们将他设成f(n),公式中的O，表示代码执行时间T(n)与f(n)成正比。所以上面的两个例子，可以分别表示为T(n)=O(100*       2+1)与T(n)=O(1+2n),当n很大时，公式中的常量、低阶、系数并不会左右增长趋势，所以都可以忽略，我们只要记录最大的量级就可以了。T(n)=O(100*2+1)可以表示为T(n)=O(100 * 2 +1）* n<sup>0</sup>=O(1),同理第二个例子T(n)=O(n).

   ## 如何进行时间复杂度的分析

   

   #### 1.只关注循环执行次数最多的那一段代码

   ​		在刚才说到O这种时间复杂度方法只是表示一种变化趋势。我们通常会忽视其中的低阶、常量、系数。所以我们只需要关注循环执行次数最多的那一段代码就好了。

   #### 2.加法法则：总复杂度等于量级最大的那段代码的复杂度

   - 复杂度相差数量级的情况

     例如，一个程序中，拥有两个循环，第一个复杂度为O(n),第二个为O(n<sup>2</sup>),则该程序的时间复杂度为O(n).

     公式为： T(n)= O(n)+O(n<sup>2</sup>)=max(O(n),O(n<sup>2</sup>))

   - 复杂度在同一数量级的情况

     例如，一个程序中，拥有两个循环，第一个复杂度为O(n),第二个为O(m),则该程序的时间复杂度为O(n+m).

     公式为： T(n)= O(n)+O(m)=max(O(m+n)

     #### 乘法法则：嵌套代码的复杂度等于其嵌套内外代码复杂度的乘积

     比如，多层循环， 复杂度的计算公式T1(m)*T2(n)=O(f(m) * f(n))

## 常用的复杂度量级 

常见的复杂度的量级可以分为：多项式量级和非多项式量级。

- 非多项式量级只有两个：O(2<sup>n</sup>)和O(n!)

  当数据规模急剧的增加，求解问题的执行时间就会无限的增加。所以非多项式级的时间复杂度其实是非常的低效。

- 多项式式量级

  1. **常量阶O(1)**

     只要代码中不存在循环语句，递归语句，即使有千千万万的语句，其时间复杂度也是O(1)

  2. **对数阶O(logn)**

  3. **线性阶O(n)**

  4. **线性对数阶和O(nlogn)**

  5.**平方阶:O(n<sup>2</sup>),立方阶:O(n<sup>3</sup>)  ** …… 

  在我们高中学过这几个函数的变化趋势，时间复杂度的大小对比：O(n<sup>2</sup>)>O(nlogn)>O(n)>O(logn)>O(1)

## 复杂度分析的四个概念

在平时的复杂度分析中，我们会用到以下的四个常用的复杂度分析，下面就对这四个概念进行讲解。

#### 基本概念

1. **最好时间复杂度：**最好情况执行完的时间复杂度。

2. **最坏时间复杂度：**最坏情况执行完的时间复杂度。

3. **平均时间复杂度：**代码在所有情况下执行次数的加权平均值。

4. **均摊时间复杂度**：在代码执行的复杂度中，大多数是复杂度低的情况，个别是复杂度高的情况<u>**且会时序发生**</u>时，可以将高时间复杂度向低时间复杂度均摊，均摊的结果一般为低时间复杂度。

   ------

   

   #### 为什么要提出引入这四个概念？如何去分析复杂度？

   下面就使用例子来进一步讲解这四个概念，以及使用这四个概念。

   ```java
   void find(int m,int[] nums)
   {
        for(int i=0;i<nums.length;i++)
        {
            if(nums[i]==m)
            {
            return num[i];
            }
        }
        return -1;
   }
   ```

   ​		上面的这段代码实现的功能是：从一个数组中，寻找指定的数m相同的元素，如果存在则返回该元素，如果没有返回-1.

   ​		就上面的这段简单的代码，在最好的情况下他的复杂度为O(1),即在第一个位置就寻找到该元素，并返回。在最坏的情况下他的复杂度为O(n),即在遍历完整个数组后找到该元素，或遍历完没有找到该元素。

   ​		以上的两种情况都属于极端的情况，实际中出现的概率非常的小。那该如何正确的表示上面代码的时间复杂度？这时候就要引出平均时间复杂度。

   ​		平均时间复杂度通过概率论中的加权平均值表示。

   ​		就上面这段代码为例，他的平均时间复杂度该如何计算？

   ​		在上面查找一共会有两个结果：查找到和没有查找到。假设查找到和没查找到的概率都为1/2.

   同时，0~n-1这n个位置也是概率也是相同的为1/n.根据概率乘法法则，查找0~n-1位置的概率为1/(2n).

   所以时间复杂度计算如下：
   $$
   1*1/2n+2*1/2n+3*1/2n+……+n*1/2n+n*1/n
   =(3n+1)/4
   $$
   去掉系数以及常量，复杂度的值为：O(n)

   ​		通过上面的分析，在一些程序中使用平均时间复杂度可以更好的描述他的复杂度。

   ​		下面讲解均摊复杂度，相对于上面的知识均摊复杂度更加的特殊，记住以下几点，就可以了。

   - **大多数情况下是复杂度低的操作**
   - **少部分是复杂度高的操作**
   - **时序发生**

   下面通过一个例子来讲解

   ```java
   int[] arr= new int[10];
   int len=10;
   int i=0;
   void add(int element)
   {
   //判断容量是否充足
       if(i>=len)
   	{创建一个新的数组
   	int[] array=new int[len*2];
   	//将旧数组中的数据全部赋值给新数组
   	for(int j=0;j<len;j++)
   	{
   	array[j]=arr[j];
   	}
   	将新数组复制给旧数组
   	arr=array;
   	len=2*len;
   	}
   	//如果数组容量充足，将该数据存入该数组中
   	a[i]=element;
   	//维护i
   	i++;
    }
   ```

   ​		上面的这段程序，我们该如何去计算他的复杂度呢？

   ​		首先，我们进行分析，当数组容量充足时，复杂度为O(1),当要进行扩容操作时，复杂度为O(n).同时高复杂度的情况是时序发生的，根据结论我们可以得到均摊复杂度为O(1).这个我们也可以通过数学期望来完成。这里就不进行验证计算了。

   